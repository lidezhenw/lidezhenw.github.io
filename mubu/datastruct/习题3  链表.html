<html>
<head>
  <title>习题3  链表</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601392 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1390"/>
<h1>习题3  链表</h1>

<div>
<span><div><div><font style="font-size: 18pt;"><span style="font-size: 18pt; font-weight: bold;">选择题</span></font></div><ul><li><div><span style="font-size: 14pt;">不带头结点的单链表head为空的判定条件是</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">head==NULL</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">带头结点的单链表head为空的判定条件是</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">head-&gt;nxt==NULL</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">非空的循环单链表head的尾结点（由p所指向）满足</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">p-&gt;next==head</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">在循环双链表的p所指结点之后插入s所指结点的操作是</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">s-&gt;left=p;s-&gt;right=p-&gt;right; p-&gt;right-&gt;left=s;p-&gt;right=s;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个单链表中，已知q所指结点是p所指结点的前驱结点，若在q和p之间插入s结点，</span><span style="font-size: 14pt;">则执行</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">q-&gt;next = s; s-&gt;next = p;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个单链表中，已知p所指结点不是最后结点，在p之后插入s所指结点，则执行</span><span style="font-size: 14pt;"><font style="color: rgb(255, 0, 0);">s-&gt;next = p-&gt;next; p-&gt;next = s;</font></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">7.在一个单链表中，若删除p所指结点的后续结点，则执行</span><span style="font-size: 14pt;"><font style="color: rgb(255, 0, 0);">p-&gt;next = p-&gt;next-&gt;next;</font></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">从一个具有n个结点的单链表中查找其值等于x结点时，在查找成功的情况下，需平均比较</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">(n+1)/2</span></span><span style="font-size: 14pt;">个结点。</span></div></li><li><div><span style="font-size: 14pt;">在一个具有n个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">O(n)</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">给定有n个元素的向量，建立一个有序单链表的时间复杂度是</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">O(n2)</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">向一个栈顶指针为HS的链栈中插入s所指结点，则执行</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">s-&gt;next = HS; HS = s;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">从一个栈顶指针为HS的链栈中删除一个结点，用x保存被删除结点的值，则执行</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">x = HS-&gt;data; HS = HS-&gt;next;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个链队中，假设f和r分别为队首和队尾指针，插入s所指结点，则执行</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">r-&gt;next = s; r = s;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个链队中，假设f和r分别为队首和队尾指针，删除一个结点，则执行</span><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0);">f = f-&gt;next;</span></span><span style="font-size: 14pt; font-family: 微软雅黑, sans-serif;">。</span></div></li></ul><div><font style="font-size: 18pt;"><span style="font-size: 18pt; font-weight: bold;">填空题</span></font></div><ul><li><div><span style="font-size: 14pt;">单链表是</span> <span style="font-size: 14pt; color: red; font-family: 微软雅黑, sans-serif;">线性表</span><span style="font-size: 14pt;">的链接存储表示。</span></div></li><li><div><span style="font-size: 14pt;">可以使用</span> <span style="font-size: 14pt; color: red; font-family: 微软雅黑, sans-serif;">双链表</span><span style="font-size: 14pt;">表示树形结构。</span></div></li><li><div><span style="font-size: 14pt;">在双链表中，每个结点有两个指针域，一个指向</span> <span style="font-size: 14pt; color: red; font-family: 微软雅黑, sans-serif;">前驱结点</span><span style="font-size: 14pt;">，另一个指向</span> <span style="font-size: 14pt; color: red; font-family: 微软雅黑, sans-serif;">后续结点</span><span style="font-size: 14pt;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个单链表中的p所指结点之前插入s所指向结点，可执行如下操作：</span></div></li><ul><li><div><span style="font-size: 14pt;">（1）s-&gt;next =</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">p-next</span><span style="font-size: 14pt;">;</span></div></li><li><div><span style="font-size: 14pt;">（2）p-&gt;next = s；</span></div></li><li><div><span style="font-size: 14pt;">（3）t = p-&gt;data；</span></div></li><li><div><span style="font-size: 14pt;">（4）p-&gt;data =</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">s-&gt;data</span><span style="font-size: 14pt;">；</span></div></li><li><div><span style="font-size: 14pt;">（5）s-&gt;data =</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">t</span><span style="font-size: 14pt;">；</span></div></li></ul><li><div><span style="font-size: 14pt;">在一单链表中删除p所指结点时，应执行以下操作：</span></div></li><ul><li><div><span style="font-size: 14pt;">（1）q = p-&gt;next；</span></div></li><li><div><span style="font-size: 14pt;">（2）p-&gt;data =</span><span style="font-size: 14pt;">p-&gt;next-&gt;data</span><span style="font-size: 14pt;">；</span></div></li><li><div><span style="font-size: 14pt;">（3）p-&gt;next =</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">p-&gt;next-&gt;next</span><span style="font-size: 14pt;">；</span></div></li><li><div><span style="font-size: 14pt;">（4）free (q)；</span></div></li></ul><li><div><span style="font-size: 14pt;">带头结点的单链表head为空的条件是</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">head-&gt;next=NULL</span><span style="font-size: 14pt;">。</span></div></li><li><div><span style="font-size: 14pt;">在一个单链表中，p所指结点之后插入s所指向结点，应执行s-&gt;next =</span> <span style="font-size: 14pt; color: rgb(255, 0, 0);">p-&gt;next</span><span style="font-size: 14pt;">和</span><span style="font-size: 14pt;">p-&gt;next =</span> <span style="font-size: 14pt; color: rgb(255, 0, 0);">s</span><span style="font-size: 14pt;">的操作。</span></div></li><li><div><span style="font-size: 14pt;">非空的循环单链表head的尾结点（由p所指向），满足条件</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">head-&gt;next=p</span></div></li><li><div><span style="font-size: 14pt;">在栈顶指针为HS的链栈中，判定栈空的条件是</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">HS==NULL</span><span style="font-size: 14pt;">。</span></div></li><li><div><span style="font-size: 14pt;">在HQ的链队中，判定只有一个结点的条件是</span><span style="font-size: 14pt; color: rgb(255, 0, 0);">HQ-&gt;front==HQ-&gt;rear</span><span style="font-size: 14pt;">。</span></div></li><li><div><span style="font-size: 14pt;">在栈顶指针为HS的链栈中，计算该链栈中结点个数的函数是</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>int count (HS)node *HS</b></div><div><b>{   node *p;</b></div><div><b>    int n=0;</b></div><div><b>p=HS;</b></div><div><b>while (p!=NULL)</b></div><div><b>{  n++;</b></div><div><b>   p=p-&gt;next;</b></div><div><b>}</b></div><div><b>return (n);</b></div><div><b>}</b></div></div><ul><li><div><span style="font-size: 14pt;">在HQ的链队中，计算该栈链中结点个数的函数是</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><b>int count (HQ)</b></div><div><b>strruct linkqueue  *HQ</b></div><div><b>{   strruct linkqueue  *p;</b></div><div><b>    int n;</b></div><div><b>p=HQ-&gt;first;</b></div><div><b>if (p==NULL) return (0 );</b></div><div><b>n=1;</b></div><div><b>while (p!=HQ-&gt;rear)</b></div><div><b>{  n++;</b></div><div><b>   p=p-&gt;next;</b></div><div><b>}</b></div><div><b>return (n);</b></div><div><b>}</b></div></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 